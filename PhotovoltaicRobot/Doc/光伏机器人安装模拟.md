# 光伏机器人自动安装程序

## 上位机设计

### 项目创建

在完成鸿蒙系统实验的基础上，我们转向Android平台的开发。首先安装Google Android Studio作为集成开发环境，选择Kotlin作为主要的开发语言。Kotlin作为JetBrains开发的现代化编程语言，与Android生态完美融n合，提供了空安全、协程等先进特性，为项目的稳定性和可维护性提供了有力保障。

在这里创建新的项目，关注开发的相关设置参数。设置相关 API 版本与依赖，并使用 Gradle Install 对环境进行配置。

![](../../assets/2025-11-04-09-38-35-image.png)

这其中主要包括使用最新的 Android API，最低支持 Android 8.0 以确保覆盖大部分设备。目标 API 级别为 36，剩下还有一些包名等等。项目的依赖管理采用了 Gradle 版本目录（Version Catalogs）机制，在 `lib.versions.toml` 中集中管理所有依赖版本。

![](../../assets/2025-11-04-09-40-37-image.png)

**关键依赖配置**：

- **Android核心库**：`androidx-core-ktx`提供Kotlin扩展功能
- **生命周期管理**：`androidx-lifecycle-runtime-ktx`和`androidx-lifecycle-viewmodel-compose`支持响应式编程
- **UI框架**：采用Jetpack Compose作为现代UI框架，依赖`androidx-compose-bom`、`androidx-compose-material3`等组件
- **测试框架**：配置JUnit、Espresso和Compose UI测试支持

**构建优化配置**：

- 启用Compose构建特性，优化UI渲染性能
- 配置Java 11兼容性，确保代码现代化
- 设置适当的混淆规则，为生产环境部署做准备

### 技术框架设计

#### Jetpack Compose UI 框架

项目采用了 Jetpack Compose 作为 UI 开发框架，这是 Google 推荐的现代化声明式 UI 工具包。相比传统的 XML 布局方式，Compose 具有代码更加直观、UI 状态与界面展示自动同步、性能更加优化的显著优势。Compose 内置了智能重组机制，能够自动检测状态变化并只更新必要的 UI 部分，这种机制在工业控制系统的实时数据显示场景中尤为重要。同时，Compose 的实时预览功能极大地提升了开发效率，开发者可以在编写代码的同时实时查看界面效果，这对于复杂控制面板的布局调试非常有帮助。

在实际项目中，Compose 框架的应用体现在多个方面。首先，通过 `@Composable` 注解定义的可组合函数构建了完整的用户界面体系，每个功能模块都对应一个独立的 Composable 组件。其次，Material Design 3 组件库的集成确保了界面风格的现代化和一致性，特别是在工业控制场景下，清晰的视觉层次和直观的操作反馈至关重要。最后，Compose 与 ViewModel 的深度集成实现了数据驱动的 UI 更新模式，当底层状态发生变化时，界面能够自动响应并刷新相应部分。

#### MVVM 架构模式

项目严格遵守 MVVM（Model-View-ViewModel）架构模式，实现了关注点的清晰分离。在架构设计中，View 层通过 Compose 编写 UI 组件，专门负责界面展示和用户交互处理。这一层的设计充分考虑了工业控制系统的特殊需求，包括实时数据更新、操作反馈及时性以及界面布局的稳定性。每个 UI 组件都保持轻量级设计，仅关注界面渲染和用户输入处理，不包含任何业务逻辑。

![](../../assets/2025-11-04-13-56-27-image.png)

ViewModel 层承担了业务逻辑和状态管理的核心职责。在项目实现中，MainViewModel 类作为主要的 ViewModel 实现，管理着整个应用的状态流转。该层通过 Kotlin 协程处理异步操作，确保网络通信和数据处理不会阻塞主线程。同时，ViewModel 层还负责协调不同模块之间的数据交互，例如当用户操作控制面板时，ViewModel 需要将操作指令转换为具体的 TCP 消息并发送到服务器。

Model 层包含了数据模型和通信管理的核心实现。这一层设计了完整的数据结构体系，包括设备状态、传感器数据、控制指令等多种数据类型。通信管理模块采用单例模式设计，封装了所有 TCP 通信逻辑，确保网络连接的稳定性和数据传输的可靠性。Model 层与 ViewModel 层通过清晰定义的接口进行交互，这种设计使得底层通信实现的变更不会影响到上层业务逻辑。

#### 响应式编程

项目引入了 Kotlin 协程和 StateFlow 实现响应式编程范式，这种设计模式特别适合处理工业控制系统中的异步数据流。在实际编码中，通过 `viewModelScope.launch` 管理异步操作，确保所有耗时的网络通信和数据处理操作都在后台线程执行，避免阻塞 UI 线程。这种机制在处理 TCP 连接建立、消息发送和数据接收等场景时尤为重要，能够保证用户界面的流畅性。

![](../../assets/2025-11-04-14-37-49-image.png)

StateFlow 作为响应式数据流的核心载体，实现了数据流的响应式更新。在项目设计中，各种系统状态都通过 StateFlow 进行封装和管理，当状态发生变化时，所有观察该状态的组件都会自动收到更新通知。这种机制在实时数据显示场景中表现出色，例如传感器数据的实时更新、设备连接状态的变化等，都能够通过 StateFlow 实现无缝的界面同步。

利用 `collectAsState()` 函数将数据流转换为 Compose 可观察状态，是响应式编程与声明式 UI 框架结合的关键技术。这种转换使得 Compose 组件能够自动订阅 StateFlow 的数据变化，并在数据更新时触发界面重组。在实际应用中，这种模式极大地简化了状态管理的复杂度，开发者无需手动处理界面更新的逻辑，只需关注数据本身的变化即可。

### 核心功能模块设计

#### 通信管理（CommunicationManager.kt）

通信管理模块（CommunicationManager.kt）采用单例模式设计，封装了所有 TCP 通信逻辑。在连接管理方面，模块实现了支持 5 秒超时的 TCP 连接机制，这种超时设置既保证了连接建立的及时性，又避免了因网络延迟导致的界面卡顿。连接建立过程中，模块会实时更新连接状态，并通过回调机制通知上层组件连接进度。

消息发送功能封装了多种消息类型的发送方法，包括位置控制命令、系统操作命令、自定义消息等不同类型。每种消息类型都有对应的发送方法，这些方法内部实现了消息格式的构建、编码和发送流程。在发送过程中，模块会检查当前连接状态，确保只有在连接建立成功的情况下才进行消息发送操作。

数据接收功能实现了传感器数据的实时接收和解析。模块通过独立的接收线程持续监听服务器发送的数据，当收到有效数据时，会进行解析并更新相应的状态对象。解析过程中采用了严格的错误处理机制，确保即使接收到格式异常的数据也不会导致应用崩溃。

错误处理机制是通信管理模块的重要组成部分。模块实现了完善的异常捕获和处理逻辑，能够识别网络超时、连接中断、数据格式错误等多种异常情况。对于每种异常，模块都会提供详细的错误信息和恢复建议，帮助用户快速定位和解决问题。

<img src="../../assets/2025-11-04-12-21-18-image.png" width="10%">

#### 状态管理（SystemState）

状态管理模块定义了完整的状态数据类体系，为整个应用提供了统一的状态管理方案。连接状态管理负责跟踪设备的连接状态变化，包括连接建立、连接中断、连接超时等多种状态。每种状态都有对应的界面表示和业务逻辑处理，确保用户能够清晰了解当前的连接状况。

位置信息管理维护着各执行机构的实时位置数据。这些数据来源于服务器的实时反馈，通过状态对象进行统一管理。位置信息的更新会触发相应的界面刷新，确保操作人员能够实时掌握设备的工作状态。同时，位置信息还用于控制逻辑的判断，例如在自动模式下，系统需要根据当前位置决定下一步的操作指令。

传感器数据管理负责处理温度、湿度、压力等多种传感器数据的采集和展示。每种传感器数据都有对应的数据模型和更新机制，确保数据的准确性和实时性。传感器数据的展示采用了图表和数值相结合的方式，既提供了直观的数据趋势，又保证了数据的精确性。

系统模式管理实现了自动模式和手动模式之间的切换功能。在不同模式下，系统的行为逻辑和用户界面都会有所差异。自动模式下，系统会根据预设的程序自动执行操作序列；手动模式下，用户可以通过控制面板直接操作各个执行机构。

#### UI组件模块化

UI 组件模块化设计将复杂的用户界面拆分为多个独立的 Compose 组件，每个组件都有明确的职责和清晰的接口。ConnectionSetup 组件负责连接配置界面的实现，提供了服务器地址设置、连接建立、连接断开等功能的用户界面。该组件设计了直观的操作流程和友好的错误提示，确保用户能够轻松完成连接配置。

<img title="" src="../../assets/72ff0830d8e09fec114c9d9f1f9d1a049bdcee1c.jpg" alt="ee1a26cb61330f7d2aeabc573b00981c.jpg" data-align="center">

StatusDisplay 组件实现了状态显示面板的功能，实时展示系统的各种状态信息。该组件采用了卡片式布局设计，将不同类型的状态信息分组展示，既保证了信息的完整性，又避免了界面过于拥挤。状态信息的更新采用了动画效果，增强了用户的视觉体验。

PositionControlPanel 组件专门负责定位机构控制的界面实现。该组件包含了抱桩夹爪控制、门架旋转控制、门架升降控制和斜梁夹爪控制等多个子模块，每个子模块都有独立的控制逻辑和状态显示。控制操作通过直观的按钮和滑块实现，确保了操作的便捷性和准确性。

OperationControlPanel 组件处理操作机构控制的界面功能。该组件包含了系统启动、停止、复位以及各种升降操作的控制按钮，每个按钮都对应特定的操作指令。按钮的状态会根据系统当前的工作模式和安全条件动态变化，确保操作的安全性和合理性。

SensorDataPanel 组件负责传感器数据的显示功能。该组件采用了多种数据可视化技术，包括实时数值显示、状态指示灯等，全面展示传感器的监测数据。数据的更新频率根据实际需求进行配置，满足不同场景下的监控需求。

这种模块化的 UI 设计不仅提高了代码的可维护性和可测试性，还使得界面开发更加高效。每个组件都可以独立开发和测试，组件之间的依赖关系清晰明确，有利于团队的协作开发。同时，模块化设计也为后续的功能扩展提供了良好的基础，新的功能模块可以很容易地集成到现有的界面体系中。

### TCP 网络通信

#### TCP 连接管理

项目基于Socket进行TCP通信，实现了完整的连接管理机制。在连接建立过程中，系统采用了标准的Socket编程接口，通过指定服务器IP地址和端口号建立TCP连接。连接管理模块设计了完善的超时机制，默认设置5秒连接超时，确保在网络异常情况下能够及时反馈连接状态。这种超时设置既考虑了工业现场网络的稳定性要求，又避免了因网络延迟导致的用户界面长时间等待。

连接状态管理是TCP通信的核心环节。系统实时监控连接状态的变化，包括连接建立成功、连接中断、连接超时等多种状态。每种状态都有对应的处理逻辑和用户界面反馈，确保操作人员能够清晰了解当前的网络状况。在连接建立成功后，系统会启动独立的接收线程持续监听服务器发送的数据，实现双向通信的实时性。

![](../../assets/2025-11-04-14-30-34-image.png)

当检测到连接异常中断时，系统会自动尝试重新建立连接，并记录重连次数和重连间隔。这种机制确保了在临时网络故障情况下，系统能够自动恢复通信，减少人工干预的需求。重连过程中，系统会保持用户界面的响应性，避免因网络操作导致的界面卡顿。

#### 多线程处理

为解决Android主线程的限制，项目采用了多线程处理机制确保网络通信的流畅性。Android平台严格限制在主线程执行网络操作，任何阻塞主线程的网络请求都会导致应用无响应（ANR）错误。为此，项目通过Kotlin协程实现了异步网络通信，将所有的TCP连接建立、消息发送和数据接收操作都放在后台线程执行。

在具体实现中，通过`viewModelScope.launch(Dispatchers.IO)`将网络操作分发到IO线程池执行。这种设计确保了主线程的流畅性，用户界面始终保持响应状态，即使在进行大规模数据传输时也不会出现卡顿现象。协程的轻量级特性使得线程切换的开销最小化，提高了系统的整体性能。

数据接收线程采用了独立的守护线程设计，持续监听服务器发送的数据包。该线程与主线程通过线程安全的数据结构进行通信，确保数据传递的准确性和及时性。当接收到有效数据时，接收线程会解析数据内容并更新相应的状态对象，状态变化通过StateFlow通知界面组件进行更新。

线程安全是多线程处理的关键考虑因素。项目中的所有共享数据都采用了适当的同步机制，包括使用`AtomicBoolean`管理连接状态、使用`Mutex`保护关键数据结构的访问等。这些机制确保了在多线程环境下数据的一致性和完整性，避免了竞态条件和数据损坏的问题。

#### 通信数据协议设计

通信数据协议设计是TCP通信的核心部分，定义了客户端与服务器之间的数据交换格式。项目采用了简洁高效的文本协议格式，便于调试和维护。协议设计遵循了工业控制系统的通用规范，确保与现有设备的兼容性。

位置控制命令采用了"POS:参数1,参数2,参数3,参数4"的格式，每个参数对应特定的控制指令。这种格式既保证了命令的清晰可读，又减少了数据传输的开销。参数之间使用逗号分隔，便于解析和处理。命令格式的设计考虑了扩展性，未来新增控制参数时可以向后兼容。

系统操作命令采用了"CMD:命令"的格式，支持多种操作指令包括START、STOP、RESET等。每种命令都有明确的语义和对应的业务逻辑，确保操作的准确性和安全性。命令设计遵循了最小权限原则，避免误操作导致的系统异常。

数据接收协议定义了服务器向客户端发送的数据格式。传感器数据采用了键值对的形式，便于解析和展示。实时状态数据包含了设备的工作状态、位置信息、传感器读数等多种信息，通过统一的格式进行封装和传输。数据格式的设计考虑了实时性要求，确保数据更新的及时性。

![loading-ag-354](../../assets/d44ac70e319fb5ce43d3b7b52f02f19a4ed9f9bf.png)

每条消息都包含了基本的格式校验，确保数据的完整性和正确性。对于关键控制命令，还实现了确认机制，客户端发送命令后等待服务器的确认响应，确保命令被正确执行。

#### 网络安全配置

在连接测试中，我们发现 Android 端一直连接不上TCP服务器，查看日志发现由于Android平台对网络安全的规范，需要在 network_security_config.xml 中配置网络安全策略，允许特定IP地址的明文通信，确保与TCP服务器的正常通信。

网络安全配置采用了精细化的域配置策略。在配置文件中，通过`<domain includeSubdomains="true">192.168.0.0</domain>`声明允许 192.168.0.0 网段的明文通信。这种配置针对常见的局域网环境，该网段通常是工业设备的标准配置。includeSubdomains 属性设置为true确保了该网段下所有子域的安全策略一致性。

配置还包含了常用的IP地址段，包括 192.168.0.0/24 和 172.20.10.0/24 等。这种多域配置方案确保了应用在不同网络环境下的兼容性，无论是标准的192.168网段还是特定的172网段都能够正常通信。每个域配置都独立声明，便于维护和修改。

配置的生效机制通过AndroidManifest.xml中的`android:networkSecurityConfig`属性实现。这种声明式的配置方式确保了安全策略在应用启动时即生效，避免了运行时配置的复杂性。同时，这种机制也便于不同构建变体使用不同的安全配置，满足开发和生产的差异化需求。

```xml
<domain-config cleartextTrafficPermitted="true">
    <domain includeSubdomains="true">192.168.0.0</domain>
    <domain includeSubdomains="true">172.20.10.0</domain>
</domain-config>
```

## 模拟终端设计

### TCP 通信

项目利用Socket通信设计了一个简单的TCP服务器来模拟终端操作，这个服务器作为机器人控制系统的接收端，用于验证Android客户端TCP通信功能的正确性。服务器采用C语言编写，运行在Linux环境下，监听5678端口，能够同时处理多个客户端的连接请求。这种设计模拟了工业现场中多个控制终端同时访问设备服务器的真实场景。

服务器采用了标准的Socket编程接口，创建TCP套接字并绑定到指定端口。通过设置 SO_REUSEADDR 选项，确保服务器在重启后能够立即重新绑定端口，避免了端口占用导致的启动失败问题。服务器监听队列设置为 10，能够处理适中的并发连接请求，满足测试环境的需求。

多客户端支持是通过多线程机制实现的。每当有新的客户端连接时，服务器会创建一个新的线程专门处理该客户端的通信。这种设计确保了每个客户端连接的独立性，避免了单个客户端的异常影响其他连接的正常通信。线程分离机制使得主线程能够继续接受新的连接请求，提高了服务器的并发处理能力。

<img title="" src="../../assets/2025-11-04-14-03-50-image.png" alt="" data-align="center">

### 客户端连接处理

客户端连接处理是模拟终端的核心功能。当客户端成功连接后，服务器会获取客户端的IP地址信息，并在控制台输出连接日志。这种日志机制便于开发人员监控连接状态，及时发现连接异常。服务器使用fdopen函数将套接字文件描述符转换为文件流，简化了后续的读写操作。

数据接收采用getline函数逐行读取客户端发送的消息。这种读取方式能够自动处理不同长度的消息，避免了固定缓冲区可能导致的截断问题。每接收到一条消息，服务器都会在控制台输出消息内容和客户端IP，便于实时监控通信过程。

消息响应机制设计为简单的回显模式。服务器收到客户端消息后，会立即回复"Server 收到: "加上原始消息内容。这种设计既验证了双向通信的正常性，又为客户端提供了明确的反馈，便于调试和功能验证。fflush函数的调用确保了响应消息能够立即发送到客户端，避免了缓冲区延迟导致的通信不同步。

连接断开检测通过getline函数的返回值实现。当客户端主动断开连接或网络异常时，getline会返回错误或EOF，服务器会清理相关资源并输出断开日志。这种机制确保了服务器资源的及时释放，避免了内存泄漏和文件描述符耗尽的问题。

### 模拟状态管理

<img src="../../assets/2025-11-04-14-21-52-image.png" title="" alt="" data-align="center">

命令解析与处理模块负责接收和解析客户端发送的控制命令，并根据命令类型更新设备状态。系统支持多种命令格式，包括系统操作命令、位置控制命令、模式切换命令等。系统操作命令包括启动、停止、复位等基本操作。启动命令将设备切换到自动工作模式，停止命令暂停设备运行，复位命令将设备状态恢复到初始值。

<img title="" src="../../assets/2025-11-04-14-22-18-image.png" alt="" data-align="center">
